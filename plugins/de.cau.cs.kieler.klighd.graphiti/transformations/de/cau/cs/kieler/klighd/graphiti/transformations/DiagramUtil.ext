import mm;
import mm::pictograms;
import mm::algorithms;
import mm::algorithms::styles;

import annotations;

/**
 * Creation and caching of the Diagram root element,
 *  used a cached extension in order to reduce parameters
 *  in the extension signatures
 */
create Diagram getDiagram():
 this.setLink(new PictogramLink) ->
 
 // this is needed to synthesize valid diagrams to be displayed by a graphiti editor
 this.setGraphicsAlgorithm(
   let rect = new Rectangle:
   rect.setHeight(1000) ->
   rect.setWidth(1000) ->   
   rect
  )  
;


/**
 *
 */
create Shape createShape(Object o):
  this.setActive(true) ->
  this.setVisible(true) ->
  this.setLink(new PictogramLink) ->
  getDiagram().children.add(this)
;

/**
 * Just a wrapper to be used to reveal the shape
 *  indicating that it has been created already!
 */
Shape getShape(Object o):
  o.createShape()
;


Anchor createVisibleFixPointAnchor(Shape shape, int x, int y):
  let anchor = new FixPointAnchor:
  anchor.setActive(true) ->
  anchor.setVisible(true) ->
  anchor.setLocation(createPoint(x,y)) ->
  anchor.setLink(new PictogramLink) ->
  anchor.setReferencedGraphicsAlgorithm(shape.graphicsAlgorithm) ->
  shape.anchors.add(anchor) ->
  anchor
;


Connection createConnection():
  let connection = new FreeFormConnection:
  let polyline = new Polyline:
  polyline.setLineWidth(1) ->
  polyline.setForeground(getColor("black")) ->
  connection.setActive(false) ->
  connection.setVisible(true) ->
  connection.setGraphicsAlgorithm(polyline) ->
  connection.setLink(new PictogramLink) ->  
  getDiagram().connections.add(connection) ->
  connection
;


Point createPoint(int x, int y):
  let point = new Point:
  point.setX(x) ->
  point.setY(y) ->
  point
;


/**
  *
  */
Rectangle createRectangle(int x, int y, int width, int height, int lineWidth, Color fg, Color bg):
 let rect = new Rectangle:
 rect.setX(x) ->
 rect.setY(y) ->
 rect.setHeight(height) ->
 rect.setWidth(width) ->
 rect.setFilled(true) ->
 rect.setLineVisible(true) ->
 rect.setLineWidth(lineWidth) ->
 rect.setBackground(bg) ->
 rect.setForeground(fg) ->
 rect
;


Rectangle createRectangle(Shape shape, int x, int y, int width, int height, Style style):
  let rectangle = createRectangle(x,y,width,height,style):
  shape.setGraphicsAlgorithm(rectangle) ->
  rectangle
;


/**
  *
  */
Rectangle createRectangle(int x, int y, int width, int height, Style style):
 let rect = new Rectangle:
 rect.setX(x) ->
 rect.setY(y) ->
 rect.setHeight(height) ->
 rect.setWidth(width) ->
 rect.setFilled(true) ->
 rect.setLineVisible(true) ->
 rect.setStyle(style) ->
 rect
;


/**
  *
  */
Ellipse createEllipse(int x, int y, int width, int height, int lineWidth, Color fg, Color bg):
 let ellipse = new Ellipse:
 ellipse.setX(x) ->
 ellipse.setY(y) ->
 ellipse.setHeight(height) ->
 ellipse.setWidth(width) ->
 ellipse.setFilled(true) ->
 ellipse.setLineVisible(true) ->
 ellipse.setLineWidth(lineWidth) ->
 ellipse.setBackground(bg) ->
 ellipse.setForeground(fg) ->
 ellipse
;


Ellipse createEllipse(Shape shape, int x, int y, int width, int height, Style style):
  let ellipse = createEllipse(x,y,width,height,style):
  shape.setGraphicsAlgorithm(ellipse) ->
  ellipse
;


/**
  *
  */
Ellipse createEllipse(int x, int y, int width, int height, Style style):
 let ellipse = new Ellipse:
 ellipse.setX(x) ->
 ellipse.setY(y) ->
 ellipse.setHeight(height) ->
 ellipse.setWidth(width) ->
 ellipse.setFilled(true) ->
 ellipse.setLineVisible(true) ->
 ellipse.setStyle(style) ->
 ellipse
;


/**
 *
 */
Ellipse createCircle(Shape shape, int x, int y, int radius, Style style):
  let ellipse = createEllipse(x,y,radius,radius,style):
  shape.setGraphicsAlgorithm(ellipse) ->
  ellipse
;


/**
 *
 */
Text createText(GraphicsAlgorithm ga, String value):
  createText(ga, value, "default")
;

Text createText(GraphicsAlgorithm ga, String value, String style):
  let text = new Text:
  text.setFont(getLabelFont(style)) ->
  text.setForeground(getColor("black")) ->
  text.setWidth(ga.width) ->
  text.setHorizontalAlignment(Orientation::ALIGNMENT_CENTER) ->
  text.setValue(value) ->
  ga.graphicsAlgorithmChildren.add(text) ->
  text
;

Property createProperty(String key, String value):
  let property = new Property:
  property.setKey(key) ->
  property.setValue(value) ->
  property
;


/**
 * Creation of the color elements
 *  allows to refer to colors by name
 *  adds them to the diagram on demand
 */
create Color getColor(String name):
 switch (name) {
   case "black" : (
    this.setRed(0) ->
    this.setGreen(0) ->
    this.setBlue(0) ->
    this)
   case "blue" : (
    this.setRed(51) ->
    this.setGreen(51) ->
    this.setBlue(153) ->
    this)
   case "darkGray" : (
    this.setRed(105) ->
    this.setGreen(105) ->
    this.setBlue(105) ->
    this)
   case "darkOrange" : (
    this.setRed(248) ->
    this.setGreen(179) ->
    this.setBlue(0) ->
    this)
   case "error" : (
    this.setRed(255) ->
    this.setGreen(0) ->
    this.setBlue(0) ->
    this)
   case "gray" : (
    this.setRed(190) ->
    this.setGreen(190) ->
    this.setBlue(190) ->
    this)
   case "lemon" : (
    this.setRed(255) ->
    this.setGreen(250) ->
    this.setBlue(205) ->
    this)
   case "red" : (
    this.setRed(255) ->
    this.setGreen(0) ->
    this.setBlue(0) ->
    this)
   case "white" : (
    this.setRed(255) ->
    this.setGreen(255) ->
    this.setBlue(255) ->
    this)
   case "yellow" : (
    this.setRed(255) ->
    this.setGreen(255) ->
    this.setBlue(0) ->
    this)
   default :
    null
 } ->
 getDiagram().colors.add(this)
;


/**
 * Creation of the available style collection
 *  allows to refer to colors by name
 *  adds them to the diagram on demand
 */
create Style getStyle(String name):
 switch(name) {
   case "black_lemon" : (
    this.setId("black_lemon") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("lemon")) ->
    this.setLineWidth(1) ->
    this)
   case "black_white" : (
    this.setId("black_white") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("white")) ->
    this.setLineWidth(4) ->
    this)
   case "black_black" : (
    this.setId("black_black") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("black")) ->
    this.setLineWidth(4) ->
    this)
   case "black_gray" : (
    this.setId("black_gray") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("gray")) ->
    this.setLineWidth(4) ->
    this)
   case "black_darkGray" : (
    this.setId("black_darkGray") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("darkGray")) ->
    this.setLineWidth(4) ->
    this)
   case "red" : (
    this.setId("red") ->
    this.setForeground(getColor("red")) ->
    this.setBackground(getColor("white")) ->
    this.setLineWidth(4) ->
    this)
   default :
    null
 } ->
 getDiagram().styles.add(this)
;


/**
 * Creation of the available font collection
 *  here we will use the same font for all labels
 *  adds it to the diagram on demand
 */
create Font getLabelFont(String name):
  switch (name) {
    case "10" : (
      this.setName("Arial") ->
      this.setSize(10) ->
      this.setBold(false) ->
      this)
    case "11" : (
      this.setName("Arial") ->
      this.setSize(11) ->
      this.setBold(false) ->
      this)
    case "12" : (
      this.setName("Arial") ->
      this.setSize(12) ->
      this.setBold(false) ->
      this)
    case "bold" : (
      this.setName("Arial") ->
      this.setSize(8) ->
      this.setBold(true) ->
      this)
    case "bold10" : (
      this.setName("Arial") ->
      this.setSize(10) ->
      this.setBold(true) ->
      this)
    case "bold12" : (
      this.setName("Arial") ->
      this.setSize(12) ->
      this.setBold(true) ->
      this)
    case "default" : (
      this.setName("Arial") ->
      this.setSize(8) ->
      this.setBold(false) ->
      this)
    default :
      null
  } ->
  getDiagram().fonts.add(this)
;


/**
 * ints is assumed to contain at least 1 entry
 */
int max(List[int] ints):
  let maxRemainder = (ints.size == 1?ints.first():ints.withoutFirst().max()):
  (ints.first() >= maxRemainder?ints.first():maxRemainder)
;


create IntAnnotation getIntProperty(Shape shape, String name):
  this.setName(name) ->
  this.setValue(0)
;


IntAnnotation getAndAddIntProperty(Shape shape, String name):
  let intAnno = shape.getIntProperty(name):
  intAnno.setValue(intAnno.value + 1) ->
  intAnno
;


Void debug(List l):
  JAVA de.cau.cs.kieler.klighd.graphiti.transformations.DiagramUtil.debug(java.util.List)
;
