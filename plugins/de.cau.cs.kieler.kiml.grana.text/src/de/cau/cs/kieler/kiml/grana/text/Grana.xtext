grammar de.cau.cs.kieler.kiml.grana.text.Grana
hidden(WS, ML_COMMENT, SL_COMMENT)

generate grana "http://www.cau.de/cs/kieler/kiml/grana/text/Grana"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://elk.eclipse.org/KLayoutData"
import "http://elk.eclipse.org/KGraph"

Grana:
    ('globalResources' (globalResources+=GlobalResourceRef)*)?
    ('globalOutputs' (gloobalOutputs+=GlobalOutputRef)*)?
    
    ('execute' (parallel?='parallel')?
              (executeAll ?= 'all' | (execute+=[Job | ID])+))
    
    (jobs+=Job)+
;

Job:
    RegularJob | RangeJob | CompareJob
;

RegularJob:
    'job' (name=ID)
    
    (layoutBeforeAnalysis ?= 'layoutBeforeAnalysis')?
    
    (measureExecutionTime ?= 'measureExecutionTime')?
    
    'resources'
        (resources+=Resource)+
    
    'layoutoptions'
        (layoutOptions+=KIdentifier)+
        
    'analyses'
        (analyses+=Analysis)+
        
    'output'
        outputType=OutputType? output=Output
;

CompareJob:
    'comparejob' name=ID
    
    'resources' (resources+=Resource)+
    
    'layoutoptions'
        (layoutOptions+=KIdentifier)
        (layoutOptions+=KIdentifier)
    
    'analyses'
        (analyses+=Analysis)+
        
    'output'
        outputType=OutputType? output=Output
;

RangeJob:
    'rangejob' name=ID
    
    (measureExecutionTime ?= 'measureExecutionTime')?
    
    'resources' (resources+=Resource)+
    
    'layoutoptions'
        (layoutOptions+=KIdentifier)+
    
    'analyses'
        (analyses+=Analysis)+
    
    'rangeoption'
        rangeOption=QualifiedID
        rangeValues=Range
            
    (('rangeanalysis'
        rangeAnalysis=Analysis
        ('component' rangeAnalysisComponent=NATURAL)?)
     |
     'rangeanalyses'
        (rangeAnalyses+=Analysis)+)
    
    'output'
        outputType=OutputType? output=Output
;

Range:
    FloatRange | IntRange
;

FloatRange:
    'floatvalues' values+=Float (',' values+=Float)*
;

IntRange:
    IntRangeRange | IntRangeValues
;

IntRangeValues:
    'intvalues' values+=NATURAL (',' values+=NATURAL)*
;

IntRangeRange:
    'intrange' start=NATURAL 'to' end=NATURAL   
;
/*
 * ---- Resources ---- 
 */
Resource:
    ResourceReference | LocalResource
;

ResourceReference:
    'ref' (resourceRefs+=[GlobalResourceRef | ID])+
;

GlobalResourceRef:
    name=ID (resources+=LocalResource)
;

LocalResource:
    path=STRING ('filter' filter=STRING)
;

/*
 * ---- Output ---- 
 */
Output:
    OutputReference | LocalOutput
;

GlobalOutputRef:
    name=ID output=LocalOutput
;

OutputReference: 
    'ref' outputRef=[GlobalOutputRef | ID]
;

LocalOutput:
    path=STRING
;

enum OutputType:
    csv | json // first literal is default
;

Analysis:
    name=QualifiedID
;


KIdentifier returns KIdentifier:
    {KIdentifier}
    id=ID
     '{' 
        (persistentEntries+=PersistentEntry (persistentEntries+=PersistentEntry)*)? 
     '}'
;

PersistentEntry returns PersistentEntry:
    key=QualifiedID ':' value=PropertyValue
;

QualifiedID returns ecore::EString:
    ID ('.' ID)*;


PropertyValue returns ecore::EString:
    BOOLEAN | STRING | Float | QualifiedID;
    

Float returns ecore::EFloat:
    TFLOAT | NATURAL;
    
    /* Terminals */

terminal TFLOAT returns ecore::EFloat:
    ('+' | '-') (
        ('0'..'9')+ ('.' ('0'..'9')*)? (('e' | 'E') ('+' | '-')? ('0'..'9')+)?
        | '.' ('0'..'9')+ (('e' | 'E') ('+' | '-')? ('0'..'9')+)?
    )
    | ('0'..'9')+ '.' ('0'..'9')* (('e' | 'E') ('+' | '-')? ('0'..'9')+)?
    | '.' ('0'..'9')+ (('e' | 'E') ('+' | '-')? ('0'..'9')+)?
    | ('0'..'9')+ ('e' | 'E') ('+' | '-')? ('0'..'9')+;
    
terminal NATURAL returns ecore::EInt:
    ('0'..'9')+;

terminal BOOLEAN returns ecore::EBoolean:
    'true' | 'false';
    
terminal STRING :
    // chsch: added '\'' alternative! 
    '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\') | !('\\'|'"') )* '"';

terminal ID:
    // chsch: the optional leading '^' is the implicit keyword escape character
    '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
terminal WS         : (' '|'\t'|'\r'|'\n')+;
    
