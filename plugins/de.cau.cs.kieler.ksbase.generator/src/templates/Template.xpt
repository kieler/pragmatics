«IMPORT featureDefinition»;
«EXTENSION templates::Extensions»
«DEFINE main FOR featureDefinition::FeatureDefinitions-»
«LET getTargetPackageName() AS pName-»
«LET getTargetPackageFile() AS pPath-»
«FILE "src/"+pPath+"/handlers/GenericTransformationHandler.java"-»
package «pName».handlers;

import java.io.PrintStream;
import java.util.List;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.mwe.core.WorkflowContext;
import org.eclipse.emf.mwe.core.WorkflowContextDefaultImpl;
import org.eclipse.emf.mwe.core.issues.Issues;
import org.eclipse.emf.mwe.core.issues.IssuesImpl;
import org.eclipse.emf.mwe.core.issues.MWEDiagnostic;
import org.eclipse.emf.mwe.core.monitor.NullProgressMonitor;
import org.eclipse.gef.EditPart;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.handlers.HandlerUtil;

/**
 * Generic transformation code initializes and executes mweWorkflow
 * 
 * @author mim
 * 
 */
public class GenericTransformationHandler {

    private KielerWorkflow workflow;
    private boolean initialized;
    private IWorkbenchWindow window;
    private StructuredSelection currentSelection;
    
    /**
     * Default constructor
     */
    public GenericTransformationHandler() {
        initialized = false;
    }

    /**
     * Initialize workflow
     * 
     * @param event
     *            Command event
     * @param command
     *            Model transformation command
     * @return true if initialization was successful
     */
    public boolean initalize(ExecutionEvent event, String command,
            int numSelections, String fileName) {
        window = HandlerUtil.getActiveWorkbenchWindow(event);

        StructuredSelection s = (StructuredSelection) window
                .getSelectionService().getSelection();
        this.currentSelection = s;
        
        if (s.size() != numSelections)
            return false;

        List<Object> selections = s.toList();
        Object selectedObject;

        IEditorPart ep = HandlerUtil.getActiveEditor(event);
        String[] location = new String[numSelections];
        for (int loc = numSelections-1; loc >= 0; --loc) {
            selectedObject = selections.get(loc);
            location[loc] = "";
            
            if (ep instanceof DiagramEditor
                    && selectedObject instanceof EditPart) {    

                EditPart ePart = (EditPart) selectedObject;
                EObject object, parent;
                int index;
                Object model = ePart.getModel();
                if (model instanceof View) {
                    object = ((View) model).getElement();
                    parent = object.eContainer();
                    while (parent != null) {
                        index = parent.eContents().indexOf(object);
                        object = parent;
                        parent = parent.eContainer();
                        location[loc] = ".eContents.get(" + index + ")"
                                + location[loc];
                    }

                } else {
                    return false;
                }
            }
            else {
                return false;
            }
        }


        Diagram diag = ((DiagramEditor) ep).getDiagram();

        ((DiagramEditor) ep)
                .doSave(new org.eclipse.core.runtime.NullProgressMonitor());
        Resource res = diag.getElement().eResource();
        String modelFile = res.getURI().devicePath();
        
		if (fileName.contains(".")) {
            fileName = fileName.substring(0, fileName.lastIndexOf("."));
        }
        
        workflow = new KielerWorkflow("platform:" + modelFile, command,
                location, fileName);

        initialized = true;
        return true;
    }

    /**
     * Executes the workflow
     * 
     * @return
     */
    public boolean run() {
        if (!initialized) {
            return false;
        }
         WorkflowContext wfx = new WorkflowContextDefaultImpl();
        Issues issues = new IssuesImpl();
        NullProgressMonitor monitor = new NullProgressMonitor();
        
        final PrintStream oldOut = System.out;
        final PrintStream oldErr = System.err;
        System.setOut(null);
        System.setErr(null);
        
        try {
        workflow.invoke(wfx, monitor, issues);
        }
        catch (Exception e) {
            
            System.out.println(e.getMessage());
        }
        
        System.setOut(oldOut);
        System.setErr(oldErr);
        
        if (issues.hasErrors()) {
       		for (MWEDiagnostic warnings : issues.getWarnings()) {
            System.err.println("Warning: " + warnings.getMessage());
    	   }
    	   for (MWEDiagnostic errors : issues.getErrors()) {
               System.err.println("Error: " + errors.getMessage());
       	   }
       	   return false;
        } else {
            return true;
        }
    }
    
    @SuppressWarnings("unchecked")
    public void restoreSelection() {
        //wont work, has to be called AFTER the diagram has been reloaded
        ((StructuredSelection)window.getSelectionService().getSelection()).toList().addAll(currentSelection.toList());
    }
}

«ENDFILE»

«FILE "src/"+pPath+"/handlers/KielerWorkflow.java"-»
package «pName».handlers;

import org.eclipse.emf.mwe.internal.core.Workflow;
import org.eclipse.emf.mwe.utils.StandaloneSetup;
import org.eclipse.emf.mwe.utils.Writer;
import org.eclipse.emf.mwe.utils.Reader;

import org.eclipse.xtend.XtendComponent;
import org.eclipse.xtend.typesystem.emf.EmfMetaModel;

public class KielerWorkflow extends Workflow {

    Reader reader;
    XtendComponent xtendComponent;
    Writer writer;

    /**
     * Creates and initializes an oAW Workflow
     * @param modelURI URI of model instance
     * @param operation Xtend function name
     * @param modelSelections selected model elements
     */
    public KielerWorkflow(String modelURI, String operation, String[] modelSelections, String fileName) {
        super();

        StandaloneSetup setup = new StandaloneSetup();
        
        setup.addRegisterGeneratedEPackage("«modelName»");
        this.addBean(setup);
        
        // EMFReader
        reader = new Reader();
        reader.setModelSlot("model");
        reader.setUri(modelURI);
        reader.setFirstElementOnly(false);
        
        // We are using the XtendComponent,
        xtendComponent = new XtendComponent();
        // with an EMFMetaMetaModel,
        EmfMetaModel emfmodel;
        // and the SyncchartsMetamodel, loaded from the SyncchartsPackage
        emfmodel = new EmfMetaModel(
                «modelName».eINSTANCE);
        
        // Set metaModel-Slot
        xtendComponent.addMetaModel(emfmodel);
        	
        String value = "«pPath»/transformations/"+fileName+"::"+operation+"(";
        
        for (int i = 0; i < modelSelections.length; ++i) {
            value += "model"+ modelSelections[i];
            if ( i < (modelSelections.length-1) ) {
                value += ",";
            }
        }
        
        value += ")";
        
        xtendComponent
                .setInvoke(value);

        writer = new Writer();
        writer.setUri(modelURI);
        writer.setModelSlot("model");
        
        // Don't forget to add the components to the workflow !!
        this.addComponent(reader);
        this.addComponent(xtendComponent);
        this.addComponent(writer);
    }
}
«ENDFILE»


«FOREACH elements AS e»
«FILE "src/"+pPath+"/handlers/"+e.methodName+"Handler.java"-»
«copyFeatureFiles(e.fileName, pPath+"/transformations/"+e.fileName)-»
package «pName».handlers;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;

public class «e.methodName»Handler extends AbstractHandler {

    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        GenericTransformationHandler handler = new GenericTransformationHandler();
        «IF e.fileName == null || e.fileName.length == 0»
        	if (!handler.initalize(event, "«e.methodName»",«e.parameter.size», "«featureFile»")) {
        «ELSE»
        	if (!handler.initalize(event, "«e.methodName»",«e.parameter.size», "«e.fileName»")) {
        «ENDIF»
            System.out.println("Fehler beim initialisieren");
        }
        if (!handler.run()) {
            System.out.println("Fehler beim Ausführen der Transformation");
        }

        return null;
    }

}
«ENDFILE-»
«ENDFOREACH»
«FILE "plugin.xml"-»
<?xml version="1.0" encoding="UTF-8"?>
<?eclipse version="3.0"?>
<plugin>
   <extension point="org.eclipse.ui.commands">
      <?gmfgen generated="true"?>
      <category
            id="«pName-».commands.category"
            name="Sample Category">
      </category>
      «FOREACH elements AS e-»
      <command
            categoryId="«pName-».commands.category"
            id="«pName-».commands.«e.methodName»Command"
            name="«e.menuEntry-»">
      </command>
      «ENDFOREACH-»
   </extension>
   <extension
         point="org.eclipse.ui.handlers">
      «FOREACH elements AS e-»
      <handler
            class="«pName-».handlers.«e.methodName-»Handler"
            commandId="«pName-».commands.«e.methodName-»Command">
			<enabledWhen>
				<iterate
					ifEmpty="false"
               		operator="and">
            	<or>
            		«FOREACH e.parameter AS param-»
               		<instanceof
						value="«getDiagramPackage()».edit.parts.«param»EditPart">
					</instanceof>
					«ENDFOREACH-»
            	</or>
         	</iterate>
         </enabledWhen>
      </handler>
      «ENDFOREACH-»
   </extension>
   <extension
         point="org.eclipse.ui.menus">
      <menuContribution
            locationURI="menu:org.eclipse.ui.main.menu?after=additions">
         <menu
               id="«pName-».diagram.menus.«featureMenuTitle-»"
               label="«featureMenuTitle-»"
               mnemonic="M">
            «FOREACH elements AS e-»
            <command
                  commandId="«pName-».commands.«e.methodName-»Command"
                  id="«pName-».menus.«e.methodName-»Command"
                  label="«e.menuEntry-»"
                  mnemonic="S">
            </command>
            «ENDFOREACH-»
            <visibleWhen
				checkEnabled="false">
				<with
					variable="activeEditor">
					<instanceof
						value="«getDiagramPackage()».part.SyncchartsDiagramEditor">
                    </instanceof>
                  </with>
            </visibleWhen>
         </menu>
      </menuContribution>
      <menuContribution
            locationURI="toolbar:org.eclipse.ui.main.toolbar?after=additions">
         <toolbar
               id="«pName-».toolbars.«featureMenuTitle-»Toolbar">
            «FOREACH elements AS e-»
            <command
                  commandId="«pName».commands.«e.methodName-»Command"
                  icon="icons/sample.gif"
                  id="«pName-».toolbars.«e.methodName-»Command"
                  label="«e.menuEntry»"
                  tooltip="«e.menuEntry-»">
				<visibleWhen
					checkEnabled="false">
					<with
						variable="activeEditor">
						<instanceof
                           value="«getDiagramPackage()».part.SyncchartsDiagramEditor">
                     	</instanceof>
                  	</with>
               </visibleWhen>
            </command>
            «ENDFOREACH-»
         </toolbar>
      </menuContribution>
   </extension>
  </plugin>
«ENDFILE»
«copyFeatureFiles(featureFile, pPath+"/transformations/"+featureFile)-»
«FILE "META-INF/MANIFEST.MF"-»
Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: «pName»
Bundle-SymbolicName: «pName»;singleton:=true
Bundle-Version: 1.0.0.qualifier
Bundle-ClassPath: .
Export-Package: «pName».handlers
Require-Bundle: org.eclipse.emf.mwe.core,
 org.eclipse.xtend;bundle-version="0.7.0",
 org.eclipse.ui,
 org.eclipse.core.runtime,
 org.eclipse.gef,
 org.eclipse.gmf.runtime.diagram.ui,
 org.eclipse.emf.mwe.utils,
 «getDiagramPackage()»,
 «IF modelPath != null-»
 «getCurrentProjectName()-»,
 «modelPath»
 «ELSE-»
 «getCurrentProjectName()»
«ENDIF-»
Eclipse-LazyStart: true
Import-Package: org.eclipse.emf.mwe.internal.core,org.eclipse.xtend.typesystem.emf,org.eclipse.xtext
Bundle-ActivationPolicy: lazy
Bundle-RequiredExecutionEnvironment: JavaSE-1.6
«ENDFILE»
«FILE "build.properties"-»
source.. = src/
output.. = bin/
bin.includes = META-INF/,\               .
«ENDFILE»
«FILE ".project"-»
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>«getTargetProjectName()»</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.pde.ManifestBuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.pde.SchemaBuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jdt.core.javanature</nature>
		<nature>org.eclipse.pde.PluginNature</nature>
		<nature>org.eclipse.xtend.shared.ui.xtendXPandNature</nature>
	</natures>
</projectDescription>
«ENDFILE»
«FILE ".classpath"-»
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
	<classpathentry kind="output" path="bin"/>
</classpath>
«ENDFILE»
«ENDLET»
«ENDLET»
«ENDDEFINE»