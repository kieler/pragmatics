/*
 * generated by Xtext
 */
package de.cau.cs.kieler.uml.sequence.text.validation

import de.cau.cs.kieler.uml.sequence.text.sequence.DestroyLifelineEvent
import de.cau.cs.kieler.uml.sequence.text.sequence.Fragment
import de.cau.cs.kieler.uml.sequence.text.sequence.Interaction
import de.cau.cs.kieler.uml.sequence.text.sequence.Lifeline
import de.cau.cs.kieler.uml.sequence.text.sequence.OneLifelineMessage
import de.cau.cs.kieler.uml.sequence.text.sequence.Refinement
import de.cau.cs.kieler.uml.sequence.text.sequence.SelfMessage
import de.cau.cs.kieler.uml.sequence.text.sequence.SequenceDiagram
import de.cau.cs.kieler.uml.sequence.text.sequence.SequencePackage
import de.cau.cs.kieler.uml.sequence.text.sequence.TwoLifelineMessage
import java.util.HashMap
import java.util.HashSet
import java.util.Map
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class SequenceValidator extends AbstractSequenceValidator {

    // Shorter names for structural features used for validation. 
    private static val EStructuralFeature END_LEFT_COUNT = SequencePackage.Literals
        .TWO_LIFELINE_MESSAGE__SOURCE_END_EXEC_COUNT
    private static val EStructuralFeature END_LEFT = SequencePackage.Literals
        .TWO_LIFELINE_MESSAGE__SOURCE_END_EXEC
    private static val EStructuralFeature END_RIGHT_COUNT = SequencePackage.Literals
        .TWO_LIFELINE_MESSAGE__TARGET_END_EXEC_COUNT
    private static val EStructuralFeature END_RIGHT = SequencePackage.Literals
        .TWO_LIFELINE_MESSAGE__TARGET_END_EXEC
    private static val EStructuralFeature ONE_END_COUNT = SequencePackage.Literals
        .ONE_LIFELINE_MESSAGE__END_EXEC_COUNT
    private static val EStructuralFeature SELF_END_COUNT = SequencePackage.Literals
        .SELF_MESSAGE__END_EXEC_COUNT
    private static val EStructuralFeature ONE_END = SequencePackage.Literals
        .ONE_LIFELINE_MESSAGE__END_EXEC
    private static val EStructuralFeature SELF_END = SequencePackage.Literals.SELF_MESSAGE__END_EXEC

    /**
     * Validation for lifelines, such that no same identifiers are possible.
     * 
     * @param s The whole sequence diagram.
     */
    @Check
    def uniqueLifelineIds(SequenceDiagram s) {
        val life = new HashSet()
        for (lifeline : s.lifelines) {
            if (life.contains(lifeline.name)) {
                error("This Identifier is already used", lifeline, SequencePackage.Literals
                    .LIFELINE__NAME
                )
            } else {
                life.add(lifeline.name)
            }
        }
    }
    
    /**
     * Validation for the correct usage of executions, such that no execution can be closed before at 
     * least one is started.
     * 
     * @param s The whole sequence diagram.
     */
    @Check
    def correctUsageOfExecutions(SequenceDiagram s) {
        val map = new HashMap<Lifeline, Integer>()
        for (interact : s.interactions) {
            correctUsageOfExecutionsOnMessage(interact, map)
        }
    }

    /**
     * Validation for the correct usage of executions with a message between two lifelines.
     * 
     * @param m The message where the correct usage has to be checked.
     * @param map Contains the count of started executions for every lifeline.
     */
    private def dispatch correctUsageOfExecutionsOnMessage(TwoLifelineMessage m, 
        Map<Lifeline, Integer> map) {
        if (m.sourceStartExec) {
            startExec(m.sourceLifeline, map)
        }
        
        if (m.targetStartExec) {
            startExec(m.targetLifeline, map)
        }
        
        if (m.sourceEndExec) {
            endExec(m.sourceLifeline, m.sourceEndExecCount, map, END_LEFT, END_LEFT_COUNT, m)
        }
        
        if (m.targetEndExec) {
            endExec(m.targetLifeline, m.targetEndExecCount, map, END_RIGHT, END_RIGHT_COUNT, m)
        }
    }

    /**
     * Validation for the correct usage of executions with a lost of found message.
     * 
     * @param m The message where the correct usage has to be checked.
     * @param map Contains the count of started executions for every lifeline.
     */
    private def dispatch correctUsageOfExecutionsOnMessage(OneLifelineMessage m, 
        Map<Lifeline, Integer> map) {
        if (m.startExec) {
            startExec(m.lifeline, map)
        }
        
        if (m.endExec) {
            endExec(m.lifeline, m.endExecCount, map, ONE_END, ONE_END_COUNT, m)
        }
    }
    
    /**
     * Validation for the correct usage of executions with a self message.
     * 
     * @param m The message where the correct usage has to be checked.
     * @param map Contains the count of started executions for every lifeline.
     */
    private def dispatch correctUsageOfExecutionsOnMessage(SelfMessage m, Map<Lifeline, Integer> map) {
        if (m.startExec) {
            startExec(m.lifeline, map)
        }
        
        if (m.endExec) {
            endExec(m.lifeline, m.endExecCount, map, SELF_END, SELF_END_COUNT, m)
        }
    }
    
    /**
     * Executions can't be used on a destruction-event but dispatch has to be defined for every 
     * interaction.
     * 
     * @param m The message where the correct usage has to be checked.
     * @param map Contains the count of started executions for every lifeline.
     */
    private def dispatch correctUsageOfExecutionsOnMessage(DestroyLifelineEvent d, 
        Map<Lifeline, Integer> map) {
        //do nothing
    }
    
    /**
     * Executions can't be used on a fragment but dispatch has to be defined for every interaction.
     * 
     * @param m The message where the correct usage has to be checked.
     * @param map Contains the count of started executions for every lifeline.
     */
    private def dispatch correctUsageOfExecutionsOnMessage(Fragment f, Map<Lifeline, Integer> map) {
        //do nothing
    }
    
    /**
     * Executions can't be used on a refinement but dispatch has to be defined for every interaction.
     * 
     * @param m The message where the correct usage has to be checked.
     * @param map Contains the count of started executions for every lifeline.
     */
    private def dispatch correctUsageOfExecutionsOnMessage(Refinement r, Map<Lifeline, Integer> map) {
        //do nothing
    }

    /**
     * Add the execution to the map or increase the count of executions on the specific lifeline.
     * 
     * @param l The lifeline where the execution is started.
     * @param map Contains the count of started executions for every lifeline.
     */
    def startExec(Lifeline l, Map<Lifeline, Integer> map) {
        if (map.containsKey(l)) {
            var temp = map.get(l) + 1
            map.put(l, temp)
        } else {
            map.put(l, 1)
        }
    }

    /**
     * Decrease the count of executions on the specific lifeline or remove the lifeline from the map.
     * 
     * @param l The lifeline where arbitrary executions end.
     * @param endExecCount The number of executions that shall be ended.
     * @param map Contains the count of started executions for every lifeline.
     * @param feature The rule from the grammar that should cause the error.
     * @param featureCnt The rule from the grammar that should cause the error.
     * @param i The interaction that should cause the error.
     */
    def endExec(Lifeline l, int endExecCount, Map<Lifeline, Integer> map, EStructuralFeature feature,
        EStructuralFeature featureCnt, Interaction i) {
        if (map.containsKey(l)) {
            var temp = 0
            if (endExecCount > 0) {
                temp = map.get(l) - endExecCount
            } else if (endExecCount == 0) {
                temp = map.get(l) - 1
            }
            
            if (temp == 0) {
                map.remove(l)
            } else if (temp < 0) {
                if (endExecCount > 1) {
                    error("The number of executions closed is higher than the number of created", i, 
                        featureCnt
                    )
                } else {
                    error("The number of executions closed is higher than the number of created", i, 
                        feature
                    )
                }
            } else {
                map.put(l, temp)
            }
        } else {
            error("The number of executions closed is higher than the number of created", i, feature)
        }
    }
}